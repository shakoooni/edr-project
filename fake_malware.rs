//! Minimal fake malware for EDR testing: allocates high-entropy, anonymous, executable memory and writes a PE header pattern.
//! This version also sets a generic process name and uses mmap for executable memory (Linux only).

use std::ptr;
use std::thread;
use std::time::Duration;
use rand::Rng;

#[cfg(target_os = "linux")]
fn set_process_name(name: &str) {
    use std::ffi::CString;
    use libc::prctl;
    const PR_SET_NAME: libc::c_int = 15;
    let cname = match CString::new(name) {
        Ok(c) => c,
        Err(_) => return,
    };
    // Safety: name is validated, prctl is called with valid args
    unsafe {
        prctl(PR_SET_NAME, cname.as_ptr() as usize, 0, 0, 0);
    }
}

#[cfg(not(target_os = "linux"))]
fn set_process_name(_name: &str) {}

fn main() {
    // Set a generic process name
    set_process_name("[kworker/u:4]");

    // Allocate 64KB of anonymous, RWX memory
    let size = 64 * 1024;
    #[cfg(target_os = "linux")]
    unsafe {
        use libc::{mmap, MAP_ANONYMOUS, MAP_PRIVATE, PROT_EXEC, PROT_READ, PROT_WRITE};
        let addr = mmap(
            ptr::null_mut(),
            size,
            PROT_READ | PROT_WRITE | PROT_EXEC,
            MAP_PRIVATE | MAP_ANONYMOUS,
            -1,
            0,
        );
        if addr != libc::MAP_FAILED {
            let buf = addr as *mut u8;
            // Fill with random data (high entropy)
            let mut tmp = vec![0u8; size];
            rand::thread_rng().fill(&mut tmp[..]);
            std::ptr::copy_nonoverlapping(tmp.as_ptr(), buf, size);
            // Write a fake PE header (MZ) at the start
            *buf = 0x4D; // 'M'
            *buf.add(1) = 0x5A; // 'Z'
            // Write a syscall stub pattern somewhere
            let stub = [0x4C, 0x8B, 0xD1, 0xB8, 0x00, 0x00];
            let offset = 1024;
            for (i, b) in stub.iter().enumerate() {
                *buf.add(offset + i) = *b;
            }
        }
    }
    #[cfg(not(target_os = "linux"))]
    {
        let mut region: Vec<u8> = vec![0u8; size];
        rand::thread_rng().fill(&mut region[..]);
        region[0] = 0x4D; // 'M'
        region[1] = 0x5A; // 'Z'
        let stub = [0x4C, 0x8B, 0xD1, 0xB8, 0x00, 0x00];
        let offset = 1024;
        region[offset..offset+stub.len()].copy_from_slice(&stub);
        let _leak = Box::leak(region.into_boxed_slice());
    }
    // Sleep forever
    println!("Fake malware running (PID: {})", std::process::id());
    loop { thread::sleep(Duration::from_secs(60)); }
}
